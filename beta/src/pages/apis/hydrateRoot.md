---
title: hydrateRoot
---

<Intro>

`hydrateRoot` is the client-side method to hydrate a container whose HTML contents were rendered by `react-dom/server`.

```js
hydrateRoot(domNode, reactNode, options?);
```

</Intro>

- [Usage](#usage)
  - [Hydrating server-rendered HTML](#hydrating-server-rendered-html)
  - [Updating a hydrated root component](#updating-a-hydrated-root-component)
- [Reference](#reference)
  - [`hydrateRoot(domNode, reactNode[, options])`](#hydrate-root)
  - [`root.render(reactNode)`](#render-root)
  - [`root.unmount()`](#unmount-root)

---

## Usage {/*usage*/}

Call `hydrateRoot` to hydrate a <CodeStep step={1}>React component</CodeStep> into a server-rendered <CodeStep step={1}>browser DOM node</CodeStep>.

```js [[1, 3, "document.getElementById('root')"], [2, 3, "<App />"]]
import {hydrateRoot} from 'react-dom/client';

hydrateRoot(document.getElementById('root'), <App />);
````

Using `hydrateRoot()` to render a client-only app (an app without server-rendered HTML) is not supported. Use [createRoot()](/apis/createRoot) instead.

### Hydrating server-rendered HTML {/*hydrating-server-rendered-html*/}

In React, "hydration" is how React "attaches" to existing HTML that was already rendered by React in a server environment. During hydration, React will attempt to attach event listeners to the existing markup and take over rendering the app on the client.

In apps fully built with React, **you will usually only hydrate one "root", once at startup for your entire app**.

<Sandpack>

```html public/index.html
<!-- Content rendered on the server -->
<div id="root"><h1>Hello, world!</h1></div>
```

```js index.js active
import './styles.css';
import {hydrateRoot} from 'react-dom/client';
import App from './App.js';

hydrateRoot(document.getElementById('root'), App);
```

```js App.js
export default function App() {
  return <h1>Hello, world!</h1>;
}
```

</Sandpack>

Usually you shouldn't need to call `hydrateRoot` again or to call it in more places. From this point on, React will be managing the DOM of your application. If you want to update the UI, your components can do this by [using state](/apis/usestate).


### Updating a hydrated root component {/*updating-a-hydrated-root-component*/}

After the root has finished hydrating, you can call `root.render` to update the root React component.

If the component tree structure matches up with what was previously rendered, React will [preserve the state](/learn/preserving-and-resetting-state). Notice how you can type in the input, which means that the updates from repeated `render` calls every second in this example are not destructive:

<Sandpack>

```html public/index.html
<!-- Content rendered on the server -->
<div id="root"><h1>Hello, world! <!-- -->0</h1><input placeholder="Type something here"/></div>
```

```js index.js active
import {hydrateRoot} from 'react-dom/client';
import './styles.css';
import App from './App.js';

const root = hydrateRoot(
    document.getElementById('root'),
    <App counter={0} />
);

let i = 0;
setInterval(() => {
  root.render(<App counter={i} />);
  i++;
}, 1000);
```

```js App.js
export default function App({counter}) {
  return (
    <>
      <h1>Hello, world! {counter}</h1>
      <input placeholder="Type something here" />
    </>
  );
}
```

</Sandpack>

It is uncommon to call `root.render` on a hydrated root. Usually, you'll [update state](/apis/usestate) inside one of the components instead.


---
## Reference {/*reference*/}

### `hydrateRoot(domNode[, options])` {/*hydrate-root*/}

Call `hydrateRoot` to “attach” React to existing HTML that was already rendered by React in a server environment.

```js
const domNode = document.getElementById('root');
const root = hydrateRoot(domNode, reactNode);
```

React will attach to the HTML that exists inside the `domNode`, and take over managing the DOM inside it. An app fully built with React will usually only have one `hydrateRoot` call with its root component.

[See examples above.](#usage)

#### Parameters {/*parameters*/}


* `domNode`: A [DOM element](https://developer.mozilla.org/en-US/docs/Web/API/Element) that was rendered as the root element on the server.

* `reactNode`: The "React node" used to render the existing HTML. This will usually be a piece of JSX like `<App />` which was rendered with a `ReactDOM Server` method such as `renderToPipeableStream(<App />)`.

* **optional** `options`: A object contain options for this React root.

  * `onRecoverableError`: optional callback called when React automatically recovers from errors.
  * `identifierPrefix`: optional prefix React uses for ids generated by `React.useId`. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix used on the server.

#### Returns {/*returns*/}

`hydrateRoot` returns an object containing two functions `render` and `unmount` (see below).

#### Caveats {/*caveats*/}
* `hydrateRoot()` expects the rendered content to be identical with the server-rendered content. React can patch up differences in text content, but you should treat mismatches as bugs and fix them.
* In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.
* You'll likely have only one `hydrateRoot` call in your app. If you use a framework, it might do this call for you.
* If your app is client-rendered with no HTML rendered already, using `hydrateRoot()` is not supported. Use [createRoot()](/apis/createRoot) instead.

---

### `root.render(reactNode)` {/*render-root*/}

Call `root.render` to update a React component inside a hydrated React root for a browser DOM element.

```js
root.render(<App />);
```

React will update `<App />` in the hydrated `root`.

[See examples above.](#usage)

#### Parameters {/*parameters*/}

* `reactNode`: A "React node" that you want to update. This will usually be a piece of JSX like `<App />`, but you can also pass a React element constructed with [`createElement()`](/TODO), a string, a number, `null`, or `undefined`.


#### Returns {/*returns*/}

`root.render` returns `undefined`.

#### Caveats {/*caveats*/}

* If you call `root.render` before the root has finished hydrating, React will clear the existing server-rendered HTML content and switch the entire root to client rendering.

---

### `root.unmount()` {/*unmount-root*/}

Call `root.unmount` to destroy a rendered tree inside a React root.

```js
root.unmount();
```

An app fully built with React will usually not have any calls to `root.unmount`.

For pages that use React for parts of the page, it may be necessary to remove DOM nodes that React controls from the page. When removing those DOM nodes, you need to tell React to "stop" managing the content inside it by calling `root.unmount`.

Calling `root.unmount` will unmount all the components in the root and "detach" React from the root DOM node, including removing any event handlers or state in the tree. 


#### Parameters {/*parameters*/}

`root.unmount` does not accept any parameters.


#### Returns {/*returns*/}

`render` returns `null`.

#### Caveats {/*caveats*/}

* Calling `root.unmount` will unmount all the components in the tree and "detach" React from the root DOM node.

* Once you call `root.unmount` you cannot call `root.render` again on the root. Attempting to call `root.render` on an unmounted root will throw a "Cannot update an unmounted root" error.

---
